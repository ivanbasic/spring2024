# Version 0.0.55a - Method-Level Filtering (EXPERIMENTAL BRANCH)

  **WARNING: This version is on branch feature/055-custom-users-and-filters and is NOT merged to main. It's a learning experiment.**

## Overview
This lesson explores:
1. Extending JdbcUserDetailsManager properly to load custom user data
2. Creating custom UserDetails objects with additional fields
3. SQL-based filtering vs @PostFilter for performance
4. Implementing role-based data access control

## Problem Statement
**Goal:** Managers should only see employees in their department.

**Challenge:** Spring Security users (DB3) are not connected to Employee data (DB2).

**Solution:** Add employee_id to users table to create the link.

## Architecture

### Database Changes (DB3 - MySQL)

```sql
-- Added column to users table
CREATE TABLE users (
    username VARCHAR(50) NOT NULL PRIMARY KEY,
    password VARCHAR(500) NOT NULL,
    enabled BOOLEAN NOT NULL,
    employee_id INT NULL  -- NEW: Link to employee in DB2
);

-- New manager users
INSERT INTO users (username, password, enabled, employee_id) 
VALUES 
    ('ada', '{noop}ada', true, 1),   -- Employee 1 in DB2
    ('karl', '{noop}karl', true, 2); -- Employee 2 in DB2

INSERT INTO authorities (username, authority) 
VALUES 
    ('ada', 'ROLE_MANAGER'),
    ('karl', 'ROLE_MANAGER');
```

### Java Implementation

#### 1. CustomUserDetails
Extends Spring Security's User class to include employeeId:

```java
public class CustomUserDetails extends User {
    private final Integer employeeId;
    
    public CustomUserDetails(String username, String password, 
                           boolean enabled, boolean accountNonExpired,
                           boolean credentialsNonExpired, 
                           boolean accountNonLocked,
                           Collection<? extends GrantedAuthority> authorities,
                           Integer employeeId) {
        super(username, password, enabled, accountNonExpired, 
              credentialsNonExpired, accountNonLocked, authorities);
        this.employeeId = employeeId;
    }
    
    public Integer getEmployeeId() {
        return employeeId;
    }
}
```

**Key Points:**
- Nullable employeeId (users like cryptuser don't have one)
- Immutable after construction
- No business logic - just a data holder

#### 2. CustomJdbcUserDetailsManager
Properly extends JdbcUserDetailsManager to load employee_id:

```java
public class CustomJdbcUserDetailsManager extends JdbcUserDetailsManager {

    public CustomJdbcUserDetailsManager(DataSource dataSource) {
        super(dataSource);
        // Override the default query
        setUsersByUsernameQuery(
            "SELECT username, password, enabled, employee_id FROM users WHERE username = ?"
        );
    }

    @Override
    protected List<UserDetails> loadUsersByUsername(String username) {
        return getJdbcTemplate().query(
            getUsersByUsernameQuery(),
            new String[]{username},
            new CustomUserDetailsRowMapper()
        );
    }

    private class CustomUserDetailsRowMapper implements RowMapper<UserDetails> {
        @Override
        public UserDetails mapRow(ResultSet rs, int rowNum) throws SQLException {
            String username = rs.getString(1);
            String password = rs.getString(2);
            boolean enabled = rs.getBoolean(3);
            Integer employeeId = (Integer) rs.getObject(4);  // Handles NULL
            
            List<GrantedAuthority> authorities = loadUserAuthorities(username);
            
            return new CustomUserDetails(username, password, enabled, 
                                        true, true, true, 
                                        authorities, employeeId);
        }
    }
}
```

**Key Points:**
- Overrides loadUsersByUsername() - the proper extension point
- Uses custom SQL query including employee_id
- Handles NULL employee_id gracefully
- Still loads authorities using parent class method

#### 3. SecurityConfig Update

```java
@Bean
public UserDetailsService userDetailsService(
        @Qualifier("db3DataSource") DataSource dataSource) {
    LOG.info("SecurityConfig.UserDetailsService created with DB3 datasource");
    
    return new CustomJdbcUserDetailsManager(dataSource);
}
```

## SQL-Based Filtering vs @PostFilter

### Why SQL Filtering is Better

**@PostFilter Approach (NOT RECOMMENDED):**
```java
@PostFilter("hasRole('ADMIN') or filterObject.department.departmentId == principal.departmentId")
public List<Employee> getEmployees() {
    return employeeRepo.findAll();  // Fetches ALL employees
}
```

**Problems:**
1. Fetches ALL records from database
2. Filters in Java memory
3. Inefficient for large datasets
4. Can't optimize with indexes

**SQL Filtering Approach (RECOMMENDED):**
```java
public List<Employee> getEmployeesForManager(Authentication auth) {
    if (hasRole("ADMIN", auth)) {
        return employeeRepo.findAll();
    }
    
    CustomUserDetails user = (CustomUserDetails) auth.getPrincipal();
    if (user.getEmployeeId() == null) {
        return Collections.emptyList();
    }
    
    Employee manager = employeeRepo.findByEmployeeId(user.getEmployeeId());
    if (manager == null || manager.getDepartment() == null) {
        return Collections.emptyList();
    }
    
    // SQL WHERE clause - only fetches relevant records!
    return employeeRepo.findByDepartment_DepartmentId(
        manager.getDepartment().getDepartmentId()
    );
}
```

**Advantages:**
1. Database filters with WHERE clause
2. Uses indexes efficiently
3. Network transfers only needed data
4. Scales to millions of records

### Repository Method
Spring Data JPA generates the SQL automatically:

```java
public interface EmployeeRepo extends JpaRepository<Employee, Integer> {
    // Spring generates: SELECT * FROM employees WHERE department_id = ?
    List<Employee> findByDepartment_DepartmentId(Integer departmentId);
}
```

## Business Rules Implemented

| User | Role | employee_id | Can See |
|------|------|-------------|---------|
| ivan | ADMIN | null | All employees (all departments) |
| ada | MANAGER | 1 | Only dept 10 employees |
| karl | MANAGER | 2 | Only dept 20 employees |
| bcryptuser | read | null | Nothing (no employee_id) |

## API Endpoint

```
GET /db2/employees/my-team
Authorization: Bearer <jwt-token>
```

**Response for ada (dept 10 manager):**
```json
[
  { "employeeId": 1, "firstName": "Ada", "department": {"departmentId": 10} },
  { "employeeId": 3, "firstName": "Alice", "department": {"departmentId": 10} }
]
```

**Response for karl (dept 20 manager):**
```json
[
  { "employeeId": 2, "firstName": "Karl", "department": {"departmentId": 20} },
  { "employeeId": 4, "firstName": "Bob", "department": {"departmentId": 20} }
]
```

## Testing the Implementation

### 1. Get JWT for ada
```bash
curl -X POST http://localhost:8080/authenticate \
  -u ada:ada \
  -H "Content-Type: application/json"
```

### 2. Use JWT to access endpoint
```bash
curl -X GET http://localhost:8080/db2/employees/my-team \
  -H "Authorization: Bearer <ada-jwt-token>"
```

### 3. Repeat for other users
Test with:
- ivan:i (ADMIN - should see all)
- karl:karl (MANAGER - should see dept 20 only)
- cryptuser:password (no employee_id - should see nothing)

## Key Learnings

### 1. Proper Extension of JdbcUserDetailsManager
âŒ **Wrong:** Hack the SQL and hope it works
âœ… **Right:** Override loadUsersByUsername() with custom RowMapper

### 2. Performance Matters
âŒ **Wrong:** Use @PostFilter for data filtering
âœ… **Right:** Filter at SQL level using repository methods

### 3. Nullable Fields
- employee_id is nullable by design
- Not all users are employees
- Handle NULLs gracefully in Java code

### 4. Separation of Concerns
- **CustomUserDetails:** Data holder (no business logic)
- **CustomJdbcUserDetailsManager:** Data loading (no business logic)
- **EmployeeService:** Business logic (filtering rules)
- **EmployeeController:** API layer (handles HTTP)

## When to Use This Pattern

**Use SQL-based filtering when:**
- Large datasets (thousands+ records)
- Need efficient database queries
- Can express filtering logic in SQL

**Use @PostFilter when:**
- Complex filtering logic hard to express in SQL
- Need to filter based on computed/derived fields
- Working with small collections already in memory

## Why This Branch is NOT Merged

This implementation is correct and performant, but:
1. It's overkill for the demo app's simple needs
2. Adds complexity without demonstrating Spring Security features
3. The DB3â†”DB2 link is artificial for this learning context
4. Better suited for real-world applications with actual user-employee relationships

**Value:** Demonstrates professional patterns for custom authentication in production systems.

## Related Concepts
- Spring Security UserDetails
- JdbcUserDetailsManager extension
- Method security (@PreAuthorize, @PostFilter)
- Spring Data JPA derived queries
- Role-based access control (RBAC)

---
**Branch:** feature/055-custom-users-and-filters  
**Status:** Experimental - Not merged to main  
**Date:** 2025-02-02


## Important: JWT vs Basic Authentication

When using **HTTP Basic Authentication**, the `Principal` is `CustomUserDetails` directly.
When using **JWT Authentication**, the `Principal` is a `Jwt` object containing claims.

The service handles both:
```java
if (auth.getPrincipal() instanceof CustomUserDetails) {
    // Basic Auth - use directly
    user = (CustomUserDetails) auth.getPrincipal();
} else if (auth.getPrincipal() instanceof Jwt) {
    // JWT - extract username and load CustomUserDetails
    Jwt jwt = (Jwt) auth.getPrincipal();
    String username = jwt.getSubject();
    user = (CustomUserDetails) userDetailsService.loadUserByUsername(username);
}
```

This ensures the service works with both authentication methods! ðŸ”‘

## Critical Fix: JWT Authentication Support

### Initial Problem
The initial implementation failed when using JWT authentication because:
1. `JdbcUserDetailsManager.loadUserByUsername()` was not overridden
2. Parent class returned base `User` class instead of `CustomUserDetails`
3. Service tried to cast `User` to `CustomUserDetails` → ClassCastException

### The Fix
Override `loadUserByUsername()` in CustomJdbcUserDetailsManager:

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    List<UserDetails> users = loadUsersByUsername(username);
    
    if (users.isEmpty()) {
        throw new UsernameNotFoundException("User '" + username + "' not found");
    }
    
    return users.get(0); // Returns CustomUserDetails
}
```

This ensures that both Basic Auth and JWT authentication return `CustomUserDetails`.

### Service Layer Handling
The service now properly handles both authentication types:

```java
if (auth.getPrincipal() instanceof CustomUserDetails) {
    // Basic Auth - use directly
    user = (CustomUserDetails) auth.getPrincipal();
} else if (auth.getPrincipal() instanceof Jwt) {
    // JWT - load from UserDetailsService
    Jwt jwt = (Jwt) auth.getPrincipal();
    UserDetails loadedUser = userDetailsService.loadUserByUsername(jwt.getSubject());
    
    if (loadedUser instanceof CustomUserDetails) {
        user = (CustomUserDetails) loadedUser;
    }
}
```

### Key Lesson
When extending `JdbcUserDetailsManager`, you must override **both**:
- `loadUsersByUsername()` (protected) - for internal use
- `loadUserByUsername()` (public) - for external API calls