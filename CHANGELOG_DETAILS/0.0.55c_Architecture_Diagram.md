# Architecture Diagram - Lesson 055

```
┌─────────────────────────────────────────────────────────────────┐
│                         REQUEST FLOW                            │
└─────────────────────────────────────────────────────────────────┘

1. User Authentication
   ═══════════════════════════════════════════════════════
   POST /authenticate
   Basic Auth: ada:ada
        ↓
   SecurityConfig → CustomJdbcUserDetailsManager
        ↓
   DB3 (MySQL) users table
   SELECT username, password, enabled, employee_id
   WHERE username = 'ada'
        ↓
   CustomUserDetails created:
   - username: "ada"
   - authorities: ["ROLE_MANAGER"]
   - employeeId: 1
        ↓
   JWT Token generated ← returned to client


2. Protected Resource Access
   ═══════════════════════════════════════════════════════
   GET /db2/employees/my-team
   Authorization: Bearer <jwt-token>
        ↓
   Spring Security validates JWT
        ↓
   Loads CustomUserDetails from JWT
        ↓
   EmployeeController.getMyTeam(Authentication auth)
        ↓
   EmployeeService.getEmployeesForManager(auth)
        ↓
   Extracts CustomUserDetails from auth.getPrincipal()
        ↓
   Gets employeeId = 1
        ↓
   DB2 (PostgreSQL): Find employee 1
   SELECT * FROM employees WHERE employee_id = 1
        ↓
   Employee ada in department 10
        ↓
   DB2 (PostgreSQL): Filter by department
   SELECT * FROM employees WHERE department_id = 10
        ↓
   Returns: [Ada, Alice] ← Only dept 10 employees!


┌─────────────────────────────────────────────────────────────────┐
│                       DATABASE STRUCTURE                        │
└─────────────────────────────────────────────────────────────────┘

DB3 (MySQL) - Authentication
═══════════════════════════════════════
users table:
┌──────────┬──────────┬─────────┬──────────────┐
│ username │ password │ enabled │ employee_id  │
├──────────┼──────────┼─────────┼──────────────┤
│ ivan     │ {noop}i  │ true    │ null         │
│ ada      │ {noop}ada│ true    │ 1            │ ← Links to DB2!
│ karl     │ {noop}..│ true    │ 2            │ ← Links to DB2!
│ bcryptuser│{bcrypt}..│ true    │ null         │
└──────────┴──────────┴─────────┴──────────────┘

authorities table:
┌──────────┬──────────────┐
│ username │ authority    │
├──────────┼──────────────┤
│ ivan     │ ADMIN        │
│ ada      │ ROLE_MANAGER │
│ karl     │ ROLE_MANAGER │
└──────────┴──────────────┘


DB2 (PostgreSQL) - Business Data
═══════════════════════════════════════
employees table:
┌─────────────┬────────────┬───────────────┐
│ employee_id │ first_name │ department_id │
├─────────────┼────────────┼───────────────┤
│ 1           │ Ada        │ 10            │ ← Manager of dept 10
│ 2           │ Karl       │ 20            │ ← Manager of dept 20
│ 3           │ Alice      │ 10            │
│ 4           │ Bob        │ 20            │
└─────────────┴────────────┴───────────────┘


┌─────────────────────────────────────────────────────────────────┐
│                      FILTERING LOGIC                            │
└─────────────────────────────────────────────────────────────────┘

User: ivan (ADMIN, employee_id=null)
   → hasAuthority("SCOPE_ADMIN") = true
   → Returns: employeeRepo.findAll()
   → Result: ALL employees (1, 2, 3, 4)

User: ada (MANAGER, employee_id=1)
   → Find employee 1 → department 10
   → Returns: employeeRepo.findByDepartment_DepartmentId(10)
   → Result: Employees (1, 3) - Ada and Alice

User: karl (MANAGER, employee_id=2)
   → Find employee 2 → department 20
   → Returns: employeeRepo.findByDepartment_DepartmentId(20)
   → Result: Employees (2, 4) - Karl and Bob

User: bcryptuser (READ, employee_id=null)
   → employee_id is null
   → Returns: Collections.emptyList()
   → Result: NOTHING


┌─────────────────────────────────────────────────────────────────┐
│                    WHY SQL FILTERING WINS                       │
└─────────────────────────────────────────────────────────────────┘

❌ @PostFilter Approach:
   1. SELECT * FROM employees  ← Fetches 10,000 rows
   2. Load all into Java memory
   3. Filter in Java: 9,950 rows discarded
   4. Return: 50 rows
   Network: 10,000 rows transferred
   Database: Full table scan
   Memory: Hold 10,000 objects

✅ SQL Filtering Approach:
   1. SELECT * FROM employees WHERE department_id = 10  ← Fetches 50 rows
   2. Return: 50 rows
   Network: 50 rows transferred
   Database: Uses index on department_id
   Memory: Hold 50 objects

Performance: 200x better! 🚀


┌─────────────────────────────────────────────────────────────────┐
│                       CODE STRUCTURE                            │
└─────────────────────────────────────────────────────────────────┘

CustomUserDetails.java
   └─ Extends Spring's User
   └─ Adds: Integer employeeId
   └─ Immutable data holder

CustomJdbcUserDetailsManager.java
   └─ Extends JdbcUserDetailsManager
   └─ Overrides: loadUsersByUsername()
   └─ Custom SQL: SELECT username, password, enabled, employee_id
   └─ Creates CustomUserDetails objects

SecurityConfig.java
   @Bean UserDetailsService
   └─ return new CustomJdbcUserDetailsManager(dataSource);

EmployeeService.java
   └─ getEmployeesForManager(Authentication auth)
      ├─ Check if ADMIN → return all
      ├─ Extract employeeId from CustomUserDetails
      ├─ Find manager's department
      └─ Query: findByDepartment_DepartmentId(deptId)

EmployeeController.java
   @GetMapping("/db2/employees/my-team")
   └─ Calls: employeeService.getEmployeesForManager(auth)
```
